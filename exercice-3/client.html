<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat WebSocket</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="window">
        <div class="window-title">üí¨ Chat WebSocket</div>
        <div class="window-content">
            <h1>Chat WebSocket</h1>

            <div id="status">Connexion en cours...</div>

            <div id="messages"></div>

            <div class="input-container">
                <input type="text" id="messageInput" placeholder="Tapez votre message ici..." />
                <button id="sendButton">Envoyer</button>
                <button id="imageButton">üì∑ Image</button>
                <button id="timestampToggle">D√©sactiver horodatage</button>
            </div>
        </div>
    </div>

    <script>
        // Connexion au serveur WebSocket
        const ws = new WebSocket('ws://localhost:8080');

        // √âl√©ments du DOM
        const statusDiv = document.getElementById('status');
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const imageButton = document.getElementById('imageButton');
        const timestampToggle = document.getElementById('timestampToggle');

        // Variables de configuration
        let lastSentMessage = null;
        let showTimestamps = true;
        let pendingImageUrl = null;

        // Gestionnaire d'√©v√©nement pour la connexion √©tablie
        ws.onopen = function(event) {
            console.log('Connexion WebSocket √©tablie');
            statusDiv.textContent = 'Connect√© au serveur';
            statusDiv.style.backgroundColor = '#d4edda';
        };

        // Gestionnaire d'√©v√©nement pour les messages re√ßus
        ws.onmessage = function(event) {
            console.log('Message re√ßu:', event.data);

            // Extraire le contenu du message (apr√®s le timestamp et le pseudo)
            const messageMatch = event.data.match(/^\[([^\]]+)\]\s*<span[^>]+style="color:\s*([^"]+)"[^>]*>([^<]+)<\/span>:\s*(.+)$/);
            var messageContent = '';
            var username = '';
            var userColor = '';
            var imageUrl = null;

            if (messageMatch) {
                // Message avec pseudo color√©
                const timestamp = messageMatch[1];
                userColor = messageMatch[2];
                username = messageMatch[3];
                messageContent = messageMatch[4];

                // V√©rifier si le message contient une image
                const imageMatch = messageContent.match(/\[IMAGE\](.+)/);
                if (imageMatch) {
                    imageUrl = imageMatch[1];
                    messageContent = messageContent.replace(/\[IMAGE\].+/, '').trim();
                }
            } else {
                // Message sans pseudo (format de repli)
                messageContent = event.data.replace(/^\[[^\]]+\]\s*/, '');
                // V√©rifier si c'est une image seule
                const imageMatch = messageContent.match(/^\[IMAGE\](.+)/);
                if (imageMatch) {
                    imageUrl = imageMatch[1];
                    messageContent = '';
                }
            }

            const messageDiv = document.createElement('div');

            // V√©rifier si c'est notre propre message ou image
            const isOwnMessage = lastSentMessage && (
                messageContent === lastSentMessage || // Message texte
                imageUrl === lastSentMessage || // Image seule
                (messageContent && messageContent.includes(lastSentMessage)) // Message avec image
            );

            if (isOwnMessage) {
                // C'est notre message, afficher avec le style sp√©cial
                messageDiv.className = 'message own-message';
                lastSentMessage = null; // R√©initialiser apr√®s utilisation
            } else {
                // Message d'un autre utilisateur, style normal
                messageDiv.className = 'message';
            }

            // Stocker le texte complet pour la fonction de bascule
            messageDiv.dataset.fullText = event.data;

            // Fonction pour cr√©er le contenu du message
            function createMessageContent() {
                let content = '';

                // Ajouter le pseudo si disponible
                if (username && userColor) {
                    if (showTimestamps) {
                        // Avec timestamp, utiliser le format complet
                        const timestampMatch = event.data.match(/^\[([^\]]+)\]/);
                        if (timestampMatch) {
                            content = `[${timestampMatch[1]}] <span style="color: ${userColor}">${username}</span>: `;
                        }
                    } else {
                        // Sans timestamp, juste le pseudo
                        content = `<span style="color: ${userColor}">${username}</span>: `;
                    }
                }

                // Ajouter le message texte s'il y en a un
                if (messageContent) {
                    content += messageContent;
                }

                // Ajouter l'image si elle existe
                if (imageUrl) {
                    if (content) content += '<br>';
                    content += `<img src="${imageUrl}" alt="Image partag√©e" style="max-width: 300px; max-height: 200px; border-radius: 8px; margin-top: 5px;" onload="this.style.display='block'" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" /><span style="display: none; color: #999; font-size: 12px;">[Image non disponible]</span>`;
                }

                return content;
            }

            // Afficher le message
            messageContent = createMessageContent();
            if (messageContent) {
                messageDiv.innerHTML = messageContent;
            } else if (imageUrl) {
                // Cas sp√©cial : seulement une image
                messageDiv.innerHTML = `<img src="${imageUrl}" alt="Image partag√©e" style="max-width: 300px; max-height: 200px; border-radius: 8px;" onload="this.style.display='block'" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" /><span style="display: none; color: #999; font-size: 12px;">[Image non disponible]</span>`;
            }

            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        };

        // Gestionnaire d'√©v√©nement pour les erreurs
        ws.onerror = function(error) {
            console.error('Erreur WebSocket:', error);
            statusDiv.textContent = 'Erreur de connexion';
            statusDiv.style.backgroundColor = '#f8d7da';
        };

        // Gestionnaire d'√©v√©nement pour la fermeture de connexion
        ws.onclose = function(event) {
            console.log('Connexion WebSocket ferm√©e');
            statusDiv.textContent = 'D√©connect√© du serveur';
            statusDiv.style.backgroundColor = '#f8d7da';
        };

        // Fonction pour demander l'URL d'une image
        function requestImageUrl() {
            const imageUrl = prompt('Collez l\'URL de l\'image √† partager :');
            if (imageUrl && imageUrl.trim()) {
                pendingImageUrl = imageUrl.trim();
                // Mettre √† jour le placeholder pour indiquer qu'une image est pr√™te
                messageInput.placeholder = 'Tapez un message ou appuyez sur Entr√©e pour envoyer l\'image...';
                messageInput.focus();
                return true;
            }
            return false;
        }

        // Fonction pour envoyer un message ou une image
        function sendMessage() {
            const message = messageInput.value.trim();

            // Si on a une image en attente et pas de message, envoyer l'image
            if (pendingImageUrl && !message) {
                if (ws.readyState === WebSocket.OPEN) {
                    // Stocker l'URL de l'image pour l'identifier
                    lastSentMessage = pendingImageUrl;

                    // Envoyer l'image via WebSocket (format sp√©cial)
                    const imageMessage = `[IMAGE]${pendingImageUrl}`;
                    ws.send(imageMessage);

                    // R√©initialiser
                    pendingImageUrl = null;
                    messageInput.placeholder = 'Tapez votre message ici...';
                    messageInput.focus();
                }
                return;
            }

            // Si on a un message normal
            if (message && ws.readyState === WebSocket.OPEN) {
                // Si on a aussi une image en attente, l'inclure dans le message
                const finalMessage = pendingImageUrl ? `${message}\n[IMAGE]${pendingImageUrl}` : message;

                // Stocker le message pour pouvoir l'identifier quand il reviendra du serveur
                lastSentMessage = message;

                // Envoyer le message via WebSocket
                ws.send(finalMessage);

                // R√©initialiser
                pendingImageUrl = null;
                messageInput.value = '';
                messageInput.placeholder = 'Tapez votre message ici...';
                messageInput.focus();
            }
        }

        // Fonction pour basculer l'affichage des horodatages
        function toggleTimestamps() {
            showTimestamps = !showTimestamps;
            timestampToggle.textContent = showTimestamps ? 'D√©sactiver horodatage' : 'Activer horodatage';

            // Mettre √† jour tous les messages existants
            const existingMessages = messagesDiv.querySelectorAll('.message');
            existingMessages.forEach(messageDiv => {
                const fullText = messageDiv.dataset.fullText || messageDiv.innerHTML || messageDiv.textContent;

                // Stocker le texte complet si ce n'est pas d√©j√† fait
                if (!messageDiv.dataset.fullText) {
                    messageDiv.dataset.fullText = fullText;
                }

                // G√©rer les messages avec ou sans image
                function updateMessageDisplay() {
                    const messageMatch = fullText.match(/^\[([^\]]+)\]\s*<span[^>]+style="color:\s*([^"]+)"[^>]*>([^<]+)<\/span>:\s*(.+)$/);
                    var content = '';

                    if (messageMatch) {
                        const timestamp = messageMatch[1];
                        const userColor = messageMatch[2];
                        const username = messageMatch[3];
                        var messageContent = messageMatch[4];

                        // V√©rifier si le message contient une image
                        const imageMatch = messageContent.match(/\[IMAGE\](.+)/);
                        var imageUrl = null;
                        if (imageMatch) {
                            imageUrl = imageMatch[1];
                            messageContent = messageContent.replace(/\[IMAGE\].+/, '').trim();
                        }

                        // Construire le contenu selon les pr√©f√©rences
                        if (showTimestamps) {
                            content = `[${timestamp}] <span style="color: ${userColor}">${username}</span>: `;
                        } else {
                            content = `<span style="color: ${userColor}">${username}</span>: `;
                        }

                        if (messageContent) {
                            content += messageContent;
                        }

                        if (imageUrl) {
                            if (content) content += '<br>';
                            content += `<img src="${imageUrl}" alt="Image partag√©e" style="max-width: 300px; max-height: 200px; border-radius: 8px; margin-top: 5px;" onload="this.style.display='block'" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" /><span style="display: none; color: #999; font-size: 12px;">[Image non disponible]</span>`;
                        }
                    } else {
                        // Format de repli pour les anciens messages
                        content = showTimestamps ? fullText : fullText.replace(/^\[[^\]]+\]\s*/, '');
                    }

                    messageDiv.innerHTML = content;
                }

                updateMessageDisplay();
            });
        }

        // Gestionnaire d'√©v√©nement pour le bouton d'envoi
        sendButton.addEventListener('click', sendMessage);

        // Gestionnaire d'√©v√©nement pour le bouton image
        imageButton.addEventListener('click', requestImageUrl);

        // Gestionnaire d'√©v√©nement pour le bouton de bascule d'horodatage
        timestampToggle.addEventListener('click', toggleTimestamps);

        // Gestionnaire d'√©v√©nement pour la touche Entr√©e dans le champ de saisie
        messageInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });
    </script>
</body>
</html>
