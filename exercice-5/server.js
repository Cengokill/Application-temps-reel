const { createServer } = require('http');
const { Server } = require('socket.io');
const Redis = require('ioredis');
const httpServer = createServer();

// Configuration du port via les arguments de ligne de commande
const PORT = process.argv[2] ? parseInt(process.argv[2]) : 3000;

// Configuration Redis
const REDIS_URL = process.env.REDIS_URL || 'redis://localhost:6379';
const REDIS_CHANNEL = 'chat_messages';

// Connexions Redis (une pour publier, une pour souscrire)
let redisPublisher = null;
let redisSubscriber = null;
const io = new Server(httpServer,{
    cors: {
        origin: "*",
        methods: ['GET', 'POST']
    }
});

// Stockage des utilisateurs connect√©s par room
const usersByRoom = new Map();

// Stockage des sockets par nom d'utilisateur pour les messages priv√©s
const userSockets = new Map(); // username -> socket

// D√©finir les rooms disponibles
const AVAILABLE_ROOMS = ['general', 'tech'];

// Couleurs disponibles pour les pseudos
const availableColors = [
    'red', 'blue', 'darkgreen', 'orange', 'magenta',
    'black', 'pink', 'skyblue', 'brown', 'limegreen',
    'purple', 'darkblue', 'darkred', 'darkorange', 'teal'
];

// Fonction pour attribuer une couleur al√©atoire
function getRandomColor() {
    return availableColors[Math.floor(Math.random() * availableColors.length)];
}

// Syst√®me d'identifiant de messages pour √©viter les boucles infinies
let messageCounter = 0;
const instanceId = Math.random().toString(36).substring(2, 15);

/**
 * G√©n√®re un identifiant unique pour chaque message
 * Combine l'ID de l'instance et un compteur pour √©viter les collisions
 */
function generateMessageId() {
    return `${instanceId}_${++messageCounter}`;
}

// Fonction pour diffuser la liste des utilisateurs √† une room sp√©cifique
const broadcastUsersList = (roomName) => {
    const userList = usersByRoom.get(roomName) || [];
    console.log(`Liste des utilisateurs pour ${roomName}:`, userList);

    // Envoyer la liste des utilisateurs avec leurs couleurs
    const usersWithColors = userList.map(user => ({
        username: user.username,
        color: user.color
    }));

    io.to(roomName).emit('users', usersWithColors);
    console.log(`Liste des utilisateurs diffus√©e dans ${roomName}`);
};

/**
 * Initialise les connexions Redis (publisher et subscriber)
 */
async function initializeRedis() {
    try {
        // Cr√©er les connexions Redis
        redisPublisher = new Redis(REDIS_URL);
        redisSubscriber = new Redis(REDIS_URL);

        // Configurer les gestionnaires d'erreurs
        redisPublisher.on('error', (err) => {
            console.error('‚ùå Erreur Redis Publisher:', err);
        });

        redisSubscriber.on('error', (err) => {
            console.error('‚ùå Erreur Redis Subscriber:', err);
        });

        // S'abonner au canal de messages
        await redisSubscriber.subscribe(REDIS_CHANNEL);
        console.log(`üì° Instance ${instanceId} abonn√©e au canal Redis: ${REDIS_CHANNEL}`);

        // G√©rer les messages re√ßus de Redis
        redisSubscriber.on('message', (channel, messageData) => {
            if (channel === REDIS_CHANNEL) {
                try {
                    const parsedMessage = JSON.parse(messageData);
                    console.log(`üì® Message re√ßu de Redis par instance ${instanceId}:`, parsedMessage);

                    // Diffuser le message aux clients locaux (uniquement si ce n'est pas notre propre message)
                    broadcastMessageFromRedis(parsedMessage);
                } catch (error) {
                    console.error('‚ùå Erreur lors du parsing du message Redis:', error);
                }
            }
        });

        console.log(`‚úÖ Redis initialis√© avec succ√®s pour l'instance ${instanceId}`);
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'initialisation de Redis:', error);
        console.log('üí° L\'application continuera sans Redis. Les messages resteront locaux √† cette instance.');
    }
}

/**
 * Publie un message sur Redis pour diffusion √† toutes les instances
 */
async function publishMessageToRedis(messageData) {
    if (!redisPublisher) {
        console.log('‚ö†Ô∏è Redis non disponible, message non publi√©');
        return;
    }

    try {
        const messageWithId = {
            ...messageData,
            messageId: generateMessageId(),
            instanceId: instanceId
        };

        const serializedMessage = JSON.stringify(messageWithId);
        await redisPublisher.publish(REDIS_CHANNEL, serializedMessage);
        console.log(`üì§ Message publi√© sur Redis par instance ${instanceId}:`, messageWithId);
    } catch (error) {
        console.error('‚ùå Erreur lors de la publication du message sur Redis:', error);
    }
}

/**
 * Diffuse un message re√ßu de Redis aux clients locaux
 */
function broadcastMessageFromRedis(messageData) {
    const { messageId, instanceId: sourceInstanceId, room, type, ...message } = messageData;

    // √âviter de traiter nos propres messages
    if (sourceInstanceId === instanceId) {
        console.log(`üîÑ Message ${messageId} ignor√© (provenant de cette instance)`);
        return;
    }

    console.log(`üì¢ Diffusion du message ${messageId} de l'instance ${sourceInstanceId} aux clients locaux`);

    // Diffuser selon le type de message
    switch (type) {
        case 'public_message':
            // Diffuser aux autres membres de la room
            io.to(room).emit('message', message);
            break;

        case 'user_joined':
            // Diffuser l'arriv√©e d'un utilisateur
            io.to(room).emit('user_joined', message);
            break;

        case 'user_left':
            // Diffuser le d√©part d'un utilisateur
            io.to(room).emit('user_left', message);
            break;

        case 'private_message':
            // Diffuser le message priv√© au destinataire
            const targetSocket = userSockets.get(message.target);
            if (targetSocket) {
                targetSocket.emit('private_message', message);
            }
            break;

        default:
            console.log(`‚ö†Ô∏è Type de message inconnu: ${type}`);
    }
}

io.on('connection', (socket) => {
    console.log('Un client est connect√©, id:', socket.id);

    // Gestion de la connexion d'un utilisateur avec pseudonyme et room
    socket.on('user_connected', async (data) => {
        const { username, room } = data;

        // V√©rifier que la room existe
        if (!AVAILABLE_ROOMS.includes(room)) {
            socket.emit('error', { message: 'Room invalide' });
            return;
        }

        // V√©rifier si le pseudonyme est d√©j√† utilis√© globalement
        if (userSockets.has(username)) {
            console.log(`‚ùå Tentative de connexion avec un pseudonyme d√©j√† utilis√©: ${username}`);
            socket.emit('error', { 
                message: `Le pseudonyme "${username}" est d√©j√† utilis√©. Veuillez choisir un autre nom.`,
                type: 'username_taken'
            });
            return;
        }

        // Attribuer une couleur al√©atoire √† l'utilisateur
        const color = getRandomColor();

        // Stocker les informations de l'utilisateur
        socket.username = username;
        socket.room = room;
        socket.color = color;

        // Rejoindre la room (Socket.IO g√®re automatiquement l'isolation)
        socket.join(room);

        // Initialiser la room si elle n'existe pas
        if (!usersByRoom.has(room)) {
            usersByRoom.set(room, []);
        }

        // Ajouter l'utilisateur √† la room avec sa couleur
        const roomUsers = usersByRoom.get(room);
        const userExists = roomUsers.find(user => user.username === username);
        if (!userExists) {
            roomUsers.push({ username, color });
            usersByRoom.set(room, roomUsers);
        }

        // Stocker le socket pour les messages priv√©s (maintenant s√©curis√©)
        userSockets.set(username, socket);
        console.log(`üîí Utilisateur ${username} enregistr√© pour les messages priv√©s`);
        console.log(`üîí Utilisateurs connect√©s:`, Array.from(userSockets.keys()));

        console.log(`Utilisateur ${username} rejoint la room ${room} avec la couleur ${color}`);

        // Publier l'arriv√©e de l'utilisateur sur Redis
        const joinData = {
            type: 'user_joined',
            room: room,
            username: username,
            color: color
        };
        await publishMessageToRedis(joinData);

        // Diffusion locale (pour maintenir la compatibilit√©)
        socket.to(room).emit('user_joined', { username, color });

        // Diffuser la liste des utilisateurs de la room
        broadcastUsersList(room);

        // Envoyer la liste des rooms disponibles
        socket.emit('available_rooms', AVAILABLE_ROOMS);
    });

    // Gestion des messages (selon les bonnes pratiques Socket.IO)
    socket.on('message', async (msg) => {
        console.log(`Message de ${socket.username} dans ${socket.room}:`, msg);

        // V√©rifier que le socket a une room assign√©e
        if (!socket.room) {
            console.error('Socket sans room assign√©e');
            return;
        }

        // V√©rifier si c'est une commande /room
        if (msg.message && msg.message.startsWith('/room ')) {
            const newRoom = msg.message.substring(6).trim();
            
            // V√©rifier que la room existe
            if (!AVAILABLE_ROOMS.includes(newRoom)) {
                socket.emit('error', { message: `Room "${newRoom}" n'existe pas. Rooms disponibles: ${AVAILABLE_ROOMS.join(', ')}` });
                return;
            }
            
            // V√©rifier que ce n'est pas la m√™me room
            if (newRoom === socket.room) {
                socket.emit('error', { message: `Vous √™tes d√©j√† dans la room "${newRoom}"` });
                return;
            }
            
            const oldRoom = socket.room;
            
            // Publier le d√©part de l'ancienne room sur Redis
            const leaveData = {
                type: 'user_left',
                room: oldRoom,
                username: socket.username,
                color: socket.color
            };
            await publishMessageToRedis(leaveData);

            // Diffusion locale du d√©part
            socket.to(oldRoom).emit('user_left', {
                username: socket.username,
                color: socket.color
            });

            // Retirer l'utilisateur de l'ancienne room
            const oldRoomUsers = usersByRoom.get(oldRoom) || [];
            const updatedOldRoomUsers = oldRoomUsers.filter(user => user.username !== socket.username);
            usersByRoom.set(oldRoom, updatedOldRoomUsers);

            // Quitter l'ancienne room
            socket.leave(oldRoom);

            // Rejoindre la nouvelle room
            socket.join(newRoom);
            socket.room = newRoom;

            // Ajouter l'utilisateur √† la nouvelle room
            const newRoomUsers = usersByRoom.get(newRoom) || [];
            const userExists = newRoomUsers.find(user => user.username === socket.username);
            if (!userExists) {
                newRoomUsers.push({
                    username: socket.username,
                    color: socket.color
                });
                usersByRoom.set(newRoom, newRoomUsers);
            }

            // Publier l'arriv√©e dans la nouvelle room sur Redis
            const joinData = {
                type: 'user_joined',
                room: newRoom,
                username: socket.username,
                color: socket.color
            };
            await publishMessageToRedis(joinData);

            // Diffusion locale de l'arriv√©e
            socket.to(newRoom).emit('user_joined', {
                username: socket.username,
                color: socket.color
            });
            
            // Diffuser les listes mises √† jour
            broadcastUsersList(oldRoom);
            broadcastUsersList(newRoom);
            
            // Confirmer le changement de room au client
            socket.emit('room_changed', {
                oldRoom: oldRoom,
                newRoom: newRoom,
                message: `Vous avez rejoint la room "${newRoom}"`
            });
            
            console.log(`${socket.username} a chang√© de room: ${oldRoom} -> ${newRoom}`);
            return;
        }

        // Message normal
        // Publier le message sur Redis pour diffusion √† toutes les instances
        const messageData = {
            type: 'public_message',
            room: socket.room,
            username: socket.username,
            message: msg.message,
            color: socket.color
        };

        await publishMessageToRedis(messageData);

        // Diffusion locale (pour maintenir la compatibilit√© si Redis n'est pas disponible)
        const messageWithColor = {
            username: socket.username,
            message: msg.message,
            color: socket.color
        };
        socket.to(socket.room).emit('message', messageWithColor);

        console.log(`Message envoy√© aux autres membres de ${socket.room}`);
    });

    // Gestion des messages priv√©s
    socket.on('private_message', async (data) => {
        console.log(`üîí MESSAGE PRIV√â RE√áU DU SERVEUR:`);
        console.log(`üîí Exp√©diteur: ${socket.username}`);
        console.log(`üîí Destinataire: ${data.target}`);
        console.log(`üîí Message: ${data.message}`);
        console.log(`üîí Tous les utilisateurs connect√©s:`, Array.from(userSockets.keys()));

        // V√©rifier que le socket a une room assign√©e
        if (!socket.room) {
            console.error('üîí Socket sans room assign√©e');
            return;
        }

        // Publier le message priv√© sur Redis pour diffusion √† toutes les instances
        const privateMessageData = {
            type: 'private_message',
            username: data.username,
            message: data.message,
            target: data.target,
            color: socket.color
        };

        await publishMessageToRedis(privateMessageData);

        // Gestion locale (pour maintenir la compatibilit√© si Redis n'est pas disponible)
        const targetSocket = userSockets.get(data.target);
        console.log(`üîí Socket du destinataire trouv√©:`, targetSocket ? 'OUI' : 'NON');

        if (targetSocket) {
            // Envoyer le message priv√© au destinataire local
            const localPrivateMessageData = {
                username: data.username,
                message: data.message,
                color: socket.color
            };

            console.log(`üîí Envoi du message priv√©:`, localPrivateMessageData);
            targetSocket.emit('private_message', localPrivateMessageData);
            console.log(`üîí Message priv√© envoy√© de ${data.username} √† ${data.target}`);
        } else {
            console.log(`üîí Utilisateur ${data.target} non trouv√© ou d√©connect√©`);
            console.log(`üîí Utilisateurs disponibles:`, Array.from(userSockets.keys()));
            // Optionnel : envoyer un message d'erreur √† l'exp√©diteur
            socket.emit('error', { message: `Utilisateur ${data.target} non trouv√©` });
        }
    });
    
    // Gestion de la d√©connexion
    socket.on('disconnect', async () => {
        if (socket.username && socket.room) {
            console.log(`Utilisateur d√©connect√©: ${socket.username} de la room ${socket.room} (socket: ${socket.id})`);

            // Publier le d√©part sur Redis
            const leaveData = {
                type: 'user_left',
                room: socket.room,
                username: socket.username,
                color: socket.color
            };
            await publishMessageToRedis(leaveData);

            // Supprimer l'utilisateur de la room
            const roomUsers = usersByRoom.get(socket.room);
            if (roomUsers) {
                const index = roomUsers.findIndex(user => user.username === socket.username);
                if (index > -1) {
                    roomUsers.splice(index, 1);
                    usersByRoom.set(socket.room, roomUsers);
                }
            }

            // Diffusion locale du d√©part
            socket.to(socket.room).emit('user_left', { username: socket.username, color: socket.color });

            // Supprimer le socket des messages priv√©s
            userSockets.delete(socket.username);
            console.log(`üîí Utilisateur ${socket.username} supprim√© des messages priv√©s`);
            console.log(`üîí Utilisateurs restants:`, Array.from(userSockets.keys()));

            // Diffuser la nouvelle liste des utilisateurs de la room
            broadcastUsersList(socket.room);
        } else {
            console.log('Un client s\'est d√©connect√©, id:', socket.id);
        }
    });
});

// Initialisation de Redis et d√©marrage du serveur
async function startServer() {
    try {
        // Initialiser Redis
        await initializeRedis();

        // D√©marrer le serveur HTTP
        httpServer.listen(PORT, () => {
            console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
            console.log(`üì° Instance ID: ${instanceId}`);
            console.log(`üîó Redis URL: ${REDIS_URL}`);
            console.log(`üì∫ Canal Redis: ${REDIS_CHANNEL}`);
            console.log('‚úÖ Pr√™t √† recevoir des connexions !');
        });
    } catch (error) {
        console.error('‚ùå Erreur lors du d√©marrage du serveur:', error);
        process.exit(1);
    }
}

// D√©marrer le serveur
startServer();

// Gestion des erreurs du serveur
httpServer.on('error', (error) => {
    if (error.code === 'EADDRINUSE') {
        console.error(`‚ùå Erreur: Le port ${PORT} est d√©j√† utilis√©.`);
        console.error('üí° Solution: Arr√™tez le processus existant ou changez le port.');
        process.exit(1);
    } else {
        console.error('‚ùå Erreur du serveur:', error);
        process.exit(1);
    }
});

// Gestion de l'arr√™t propre du serveur
process.on('SIGINT', async () => {
    console.log('\nüõë Arr√™t du serveur...');

    // Fermer les connexions Redis
    if (redisPublisher) {
        await redisPublisher.quit();
        console.log('‚úÖ Connexion Redis Publisher ferm√©e');
    }
    if (redisSubscriber) {
        await redisSubscriber.quit();
        console.log('‚úÖ Connexion Redis Subscriber ferm√©e');
    }

    // Fermer le serveur HTTP
    httpServer.close(() => {
        console.log('‚úÖ Serveur HTTP arr√™t√© proprement');
        process.exit(0);
    });
});