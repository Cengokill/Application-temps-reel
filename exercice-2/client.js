// Configuration
const API_BASE = window.location.origin;

// √âl√©ments DOM
const statusText = document.getElementById('statusText');
const statusVersion = document.getElementById('statusVersion');
const statusDisplay = document.getElementById('statusDisplay');
const connectionStatus = document.getElementById('connectionStatus');
const statusSelect = document.getElementById('statusSelect');
const updateButton = document.getElementById('updateButton');
const adminMessage = document.getElementById('adminMessage');
const logsContainer = document.getElementById('logs');
const tickerContent = document.getElementById('tickerContent');

// √âtat local
let currentVersion = 0;
let isPolling = false;
let pollingController = null;
let tickerInterval = null;
let connectionState = 'waiting';
let totalLogs = 1; // Commence avec le log d'initialisation

// Fonction pour ajouter un log
function addLog(message, type = 'info') {
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';

    const timestamp = new Date().toLocaleTimeString();
    logEntry.setAttribute('data-timestamp', timestamp);
    logEntry.classList.add('timestamp');

    let prefix = '';
    switch(type) {
        case 'success': prefix = '‚úì '; break;
        case 'error': prefix = '‚úó '; break;
        case 'update': prefix = 'üîÑ '; break;
        default: prefix = '‚Ñπ '; break;
    }

    logEntry.textContent = prefix + message;

    logsContainer.appendChild(logEntry);
    logsContainer.scrollTop = logsContainer.scrollHeight;
    totalLogs++;
    updateTickerElement('ticker-logs', `üìù ${totalLogs} logs enregistr√©s`);
}

// Fonction pour mettre √† jour l'affichage du statut
function updateStatusDisplay(status, version) {
    statusText.textContent = status;
    statusVersion.textContent = `Version: ${version}`;

    // Supprimer toutes les classes de statut
    statusDisplay.className = 'status-display';

    // Ajouter la classe appropri√©e selon le statut
    const statusClass = 'status-' + status.toLowerCase().replace(' ', '-');
    statusText.classList.add(statusClass);

    addLog(`Statut mis √† jour: ${status} (v${version})`, 'update');

    // Mise √† jour imm√©diate des √©l√©ments concern√©s
    updateTickerElement('ticker-status', `üìä Statut: ${status}`);
    updateTickerElement('ticker-version', `üî¢ Version: ${version}`);
}

// Fonction pour initialiser le bandeau dynamique
function initializeTicker() {
    createTickerElements();
    updateTickerContent();

    // Mise √† jour de l'heure toutes les secondes (temps r√©el)
    window.timeUpdateInterval = setInterval(updateTimeDisplay, 1000);

    // Mise √† jour compl√®te des autres √©l√©ments toutes les 30 secondes
    tickerInterval = setInterval(updateTickerContent, 40000);
}

// Fonction pour mettre √† jour seulement l'heure (appel√©e chaque seconde)
function updateTimeDisplay() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('fr-FR', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
    updateTickerElement('ticker-time', `üïê ${timeString}`);
}

// Fonction pour cr√©er les √©l√©ments du bandeau avec IDs individuels
function createTickerElements() {
    const items = [
        { id: 'ticker-date', icon: 'üìÖ', text: 'Date' },
        { id: 'ticker-time', icon: 'üïê', text: 'Heure' },
        { id: 'ticker-status', icon: 'üìä', text: 'Statut' },
        { id: 'ticker-version', icon: 'üî¢', text: 'Version' },
        { id: 'ticker-connection', icon: 'üì°', text: 'Connexion' },
        { id: 'ticker-logs', icon: 'üìù', text: 'Logs' },
        { id: 'ticker-system', icon: '‚ö°', text: 'Syst√®me' }
    ];

    tickerContent.innerHTML = items.map(item =>
        `<span class="ticker-item" id="${item.id}">${item.icon} ${item.text}</span>`
    ).join('');
}

// Fonction pour mettre √† jour un √©l√©ment sp√©cifique du bandeau
function updateTickerElement(elementId, content) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = content;
    }
}

// Fonction pour mettre √† jour tous les √©l√©ments du bandeau (sauf l'heure)
function updateTickerContent() {
    const now = new Date();
    const dateString = now.toLocaleDateString('fr-FR');

    let connectionText = '';
    switch(connectionState) {
        case 'connected': connectionText = 'üü¢ Connect√©'; break;
        case 'waiting': connectionText = 'üü° En attente'; break;
        case 'error': connectionText = 'üî¥ Erreur connexion'; break;
        default: connectionText = '‚ö™ Initialisation'; break;
    }

    const statusText = document.getElementById('statusText').textContent;
    const versionText = document.getElementById('statusVersion').textContent;

    // Mise √† jour de chaque √©l√©ment individuellement (l'heure est g√©r√©e s√©par√©ment)
    updateTickerElement('ticker-date', `üìÖ ${dateString}`);
    updateTickerElement('ticker-status', `üìä Statut: ${statusText}`);
    updateTickerElement('ticker-version', `üî¢ ${versionText}`);
    updateTickerElement('ticker-connection', `üì° ${connectionText}`);
    updateTickerElement('ticker-logs', `üìù ${totalLogs} logs enregistr√©s`);
    updateTickerElement('ticker-system', `‚ö° Syst√®me en temps r√©el actif`);
}

// Fonction pour mettre √† jour le statut de connexion
function updateConnectionStatus(status, message) {
    connectionStatus.textContent = message;
    connectionStatus.className = 'connection-status connection-' + status;
    connectionState = status;

    // Mise √† jour imm√©diate seulement de l'√©tat de connexion
    let connectionText = '';
    switch(status) {
        case 'connected': connectionText = 'üü¢ Connect√©'; break;
        case 'waiting': connectionText = 'üü° En attente'; break;
        case 'error': connectionText = 'üî¥ Erreur connexion'; break;
        default: connectionText = '‚ö™ Initialisation'; break;
    }
    updateTickerElement('ticker-connection', `üì° ${connectionText}`);
}

// Fonction pour effectuer une requ√™te Long Polling
async function pollStatus() {
    if (isPolling) return;

    isPolling = true;
    updateConnectionStatus('waiting', 'En attente de mise √† jour...');

    try {
        // Cr√©er un AbortController pour pouvoir annuler la requ√™te
        pollingController = new AbortController();

        const response = await fetch(`${API_BASE}/poll-status?last_version=${currentVersion}`, {
            signal: pollingController.signal
        });

        if (response.status === 204) {
            // Pas de changement, continuer le polling
            updateConnectionStatus('waiting', 'Aucune mise √† jour, reconnexion...');
            addLog('Aucune mise √† jour re√ßue, reconnexion automatique', 'info');
        } else if (response.ok) {
            const data = await response.json();
            if (data.changed) {
                updateStatusDisplay(data.status, data.version);
                currentVersion = data.version;
                updateConnectionStatus('connected', 'Connect√© - Mise √† jour re√ßue');
            }
        } else {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
    } catch (error) {
        if (error.name === 'AbortError') {
            addLog('Requ√™te annul√©e', 'info');
        } else {
            updateConnectionStatus('error', 'Erreur de connexion');
            addLog(`Erreur de connexion: ${error.message}`, 'error');
        }
    } finally {
        isPolling = false;
        pollingController = null;

        // Relancer automatiquement le polling apr√®s un court d√©lai
        setTimeout(pollStatus, 1000);
    }
}

// Fonction pour obtenir le statut initial
async function getInitialStatus() {
    try {
        updateConnectionStatus('waiting', 'Connexion au serveur...');

        const response = await fetch(`${API_BASE}/get-status`);
        if (response.ok) {
            const data = await response.json();
            updateStatusDisplay(data.status, data.version);
            currentVersion = data.version;
            updateConnectionStatus('connected', 'Connect√©');
            addLog('Connexion √©tablie avec le serveur', 'success');

            // D√©marrer le Long Polling
            pollStatus();
        } else {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
    } catch (error) {
        updateConnectionStatus('error', 'Erreur de connexion');
        addLog(`Impossible de se connecter: ${error.message}`, 'error');

        // R√©essayer apr√®s 5 secondes
        setTimeout(getInitialStatus, 5000);
    }
}

// Fonction pour mettre √† jour le statut via l'admin
async function updateStatus(newStatus) {
    updateButton.disabled = true;
    adminMessage.textContent = 'Mise √† jour en cours...';
    adminMessage.className = 'admin-message';

    try {
        const response = await fetch(`${API_BASE}/update-status`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ status: newStatus })
        });

        if (response.ok) {
            const data = await response.json();
            adminMessage.textContent = data.message;
            adminMessage.classList.add('success');
            addLog(`Statut modifi√© manuellement: ${newStatus}`, 'success');

            // Mettre √† jour l'affichage local imm√©diatement
            updateStatusDisplay(data.status, data.version);
            currentVersion = data.version;
        } else {
            const error = await response.json();
            throw new Error(error.error || 'Erreur inconnue');
        }
    } catch (error) {
        adminMessage.textContent = `Erreur: ${error.message}`;
        adminMessage.classList.add('error');
        addLog(`Erreur lors de la mise √† jour: ${error.message}`, 'error');
    } finally {
        updateButton.disabled = false;
    }
}

// Gestionnaire d'√©v√©nement pour le bouton de mise √† jour
updateButton.addEventListener('click', () => {
    const selectedStatus = statusSelect.value;
    updateStatus(selectedStatus);
});

// Gestionnaire d'√©v√©nement pour la touche Entr√©e dans le select
statusSelect.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
        const selectedStatus = statusSelect.value;
        updateStatus(selectedStatus);
    }
});

// D√©marrer l'application
document.addEventListener('DOMContentLoaded', () => {
    addLog('Application d√©marr√©e', 'info');
    initializeTicker();
    getInitialStatus();
});

// Gestion de la fermeture de la page
window.addEventListener('beforeunload', () => {
    if (pollingController) {
        pollingController.abort();
    }
    if (tickerInterval) {
        clearInterval(tickerInterval);
    }
    // Nettoyer √©galement le timer de l'heure
    const timeIntervalId = window.timeUpdateInterval;
    if (timeIntervalId) {
        clearInterval(timeIntervalId);
    }
});
