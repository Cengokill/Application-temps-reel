const { createServer } = require('http');
const { Server } = require('socket.io');
const httpServer = createServer();
const PORT = 3000;
const io = new Server(httpServer,{
    cors: {
        origin: "*",
        methods: ['GET', 'POST']
    }
});

// Stockage des utilisateurs connect√©s par room
const usersByRoom = new Map();

// Stockage des sockets par nom d'utilisateur pour les messages priv√©s
const userSockets = new Map(); // username -> socket

// D√©finir les rooms disponibles
const AVAILABLE_ROOMS = ['general', 'tech'];

// Couleurs disponibles pour les pseudos
const availableColors = [
    'red', 'blue', 'darkgreen', 'orange', 'magenta',
    'black', 'pink', 'skyblue', 'brown', 'limegreen',
    'purple', 'darkblue', 'darkred', 'darkorange', 'teal'
];

// Fonction pour attribuer une couleur al√©atoire
function getRandomColor() {
    return availableColors[Math.floor(Math.random() * availableColors.length)];
}

// Fonction pour diffuser la liste des utilisateurs √† une room sp√©cifique
const broadcastUsersList = (roomName) => {
    const userList = usersByRoom.get(roomName) || [];
    console.log(`Liste des utilisateurs pour ${roomName}:`, userList);

    // Envoyer la liste des utilisateurs avec leurs couleurs
    const usersWithColors = userList.map(user => ({
        username: user.username,
        color: user.color
    }));

    io.to(roomName).emit('users', usersWithColors);
    console.log(`Liste des utilisateurs diffus√©e dans ${roomName}`);
};

io.on('connection', (socket) => {
    console.log('Un client est connect√©, id:', socket.id);

    // Gestion de la connexion d'un utilisateur avec pseudonyme et room
    socket.on('user_connected', (data) => {
        const { username, room } = data;

        // V√©rifier que la room existe
        if (!AVAILABLE_ROOMS.includes(room)) {
            socket.emit('error', { message: 'Room invalide' });
            return;
        }

        // V√©rifier si le pseudonyme est d√©j√† utilis√© globalement
        if (userSockets.has(username)) {
            console.log(`‚ùå Tentative de connexion avec un pseudonyme d√©j√† utilis√©: ${username}`);
            socket.emit('error', { 
                message: `Le pseudonyme "${username}" est d√©j√† utilis√©. Veuillez choisir un autre nom.`,
                type: 'username_taken'
            });
            return;
        }

        // Attribuer une couleur al√©atoire √† l'utilisateur
        const color = getRandomColor();

        // Stocker les informations de l'utilisateur
        socket.username = username;
        socket.room = room;
        socket.color = color;

        // Rejoindre la room (Socket.IO g√®re automatiquement l'isolation)
        socket.join(room);

        // Initialiser la room si elle n'existe pas
        if (!usersByRoom.has(room)) {
            usersByRoom.set(room, []);
        }

        // Ajouter l'utilisateur √† la room avec sa couleur
        const roomUsers = usersByRoom.get(room);
        const userExists = roomUsers.find(user => user.username === username);
        if (!userExists) {
            roomUsers.push({ username, color });
            usersByRoom.set(room, roomUsers);
        }

        // Stocker le socket pour les messages priv√©s (maintenant s√©curis√©)
        userSockets.set(username, socket);
        console.log(`üîí Utilisateur ${username} enregistr√© pour les messages priv√©s`);
        console.log(`üîí Utilisateurs connect√©s:`, Array.from(userSockets.keys()));

        console.log(`Utilisateur ${username} rejoint la room ${room} avec la couleur ${color}`);

        // Diffuser aux autres membres de la room
        socket.to(room).emit('user_joined', { username, color });

        // Diffuser la liste des utilisateurs de la room
        broadcastUsersList(room);

        // Envoyer la liste des rooms disponibles
        socket.emit('available_rooms', AVAILABLE_ROOMS);
    });

    // Gestion des messages (selon les bonnes pratiques Socket.IO)
    socket.on('message', (msg) => {
        console.log(`Message de ${socket.username} dans ${socket.room}:`, msg);

        // V√©rifier que le socket a une room assign√©e
        if (!socket.room) {
            console.error('Socket sans room assign√©e');
            return;
        }

        // V√©rifier si c'est une commande /room
        if (msg.message && msg.message.startsWith('/room ')) {
            const newRoom = msg.message.substring(6).trim();
            
            // V√©rifier que la room existe
            if (!AVAILABLE_ROOMS.includes(newRoom)) {
                socket.emit('error', { message: `Room "${newRoom}" n'existe pas. Rooms disponibles: ${AVAILABLE_ROOMS.join(', ')}` });
                return;
            }
            
            // V√©rifier que ce n'est pas la m√™me room
            if (newRoom === socket.room) {
                socket.emit('error', { message: `Vous √™tes d√©j√† dans la room "${newRoom}"` });
                return;
            }
            
            const oldRoom = socket.room;
            
            // Notifier le d√©part de l'ancienne room
            socket.to(oldRoom).emit('user_left', {
                username: socket.username,
                color: socket.color
            });
            
            // Retirer l'utilisateur de l'ancienne room
            const oldRoomUsers = usersByRoom.get(oldRoom) || [];
            const updatedOldRoomUsers = oldRoomUsers.filter(user => user.username !== socket.username);
            usersByRoom.set(oldRoom, updatedOldRoomUsers);
            
            // Quitter l'ancienne room
            socket.leave(oldRoom);
            
            // Rejoindre la nouvelle room
            socket.join(newRoom);
            socket.room = newRoom;
            
            // Ajouter l'utilisateur √† la nouvelle room
            const newRoomUsers = usersByRoom.get(newRoom) || [];
            const userExists = newRoomUsers.find(user => user.username === socket.username);
            if (!userExists) {
                newRoomUsers.push({
                    username: socket.username,
                    color: socket.color
                });
                usersByRoom.set(newRoom, newRoomUsers);
            }
            
            // Notifier l'arriv√©e dans la nouvelle room
            socket.to(newRoom).emit('user_joined', {
                username: socket.username,
                color: socket.color
            });
            
            // Diffuser les listes mises √† jour
            broadcastUsersList(oldRoom);
            broadcastUsersList(newRoom);
            
            // Confirmer le changement de room au client
            socket.emit('room_changed', {
                oldRoom: oldRoom,
                newRoom: newRoom,
                message: `Vous avez rejoint la room "${newRoom}"`
            });
            
            console.log(`${socket.username} a chang√© de room: ${oldRoom} -> ${newRoom}`);
            return;
        }

        // Message normal
        // Ajouter la couleur √† l'utilisateur dans le message
        const messageWithColor = {
            ...msg,
            color: socket.color
        };

        // Envoyer uniquement aux autres membres de la room
        // socket.to() = aux autres membres de la room uniquement
        socket.to(socket.room).emit('message', messageWithColor);

        console.log(`Message envoy√© aux autres membres de ${socket.room}`);
    });

    // Gestion des messages priv√©s
    socket.on('private_message', (data) => {
        console.log(`üîí MESSAGE PRIV√â RE√áU DU SERVEUR:`);
        console.log(`üîí Exp√©diteur: ${socket.username}`);
        console.log(`üîí Destinataire: ${data.target}`);
        console.log(`üîí Message: ${data.message}`);
        console.log(`üîí Tous les utilisateurs connect√©s:`, Array.from(userSockets.keys()));

        // V√©rifier que le socket a une room assign√©e
        if (!socket.room) {
            console.error('üîí Socket sans room assign√©e');
            return;
        }

        // Trouver le socket du destinataire
        const targetSocket = userSockets.get(data.target);
        console.log(`üîí Socket du destinataire trouv√©:`, targetSocket ? 'OUI' : 'NON');
        
        if (targetSocket) {
            // Envoyer le message priv√© au destinataire
            const privateMessageData = {
                username: data.username,
                message: data.message,
                color: socket.color
            };
            
            console.log(`üîí Envoi du message priv√©:`, privateMessageData);
            targetSocket.emit('private_message', privateMessageData);
            console.log(`üîí Message priv√© envoy√© de ${data.username} √† ${data.target}`);
        } else {
            console.log(`üîí Utilisateur ${data.target} non trouv√© ou d√©connect√©`);
            console.log(`üîí Utilisateurs disponibles:`, Array.from(userSockets.keys()));
            // Optionnel : envoyer un message d'erreur √† l'exp√©diteur
            socket.emit('error', { message: `Utilisateur ${data.target} non trouv√©` });
        }
    });
    
    // Gestion de la d√©connexion
    socket.on('disconnect', () => {
        if (socket.username && socket.room) {
            console.log(`Utilisateur d√©connect√©: ${socket.username} de la room ${socket.room} (socket: ${socket.id})`);
            
            // Supprimer l'utilisateur de la room
            const roomUsers = usersByRoom.get(socket.room);
            if (roomUsers) {
                const index = roomUsers.findIndex(user => user.username === socket.username);
                if (index > -1) {
                    roomUsers.splice(index, 1);
                    usersByRoom.set(socket.room, roomUsers);
                }
            }
            
            // Diffuser un message de d√©part aux autres membres de la room
            // (Socket.IO g√®re l'isolation par room - pas besoin d'inclure la room)
            socket.to(socket.room).emit('user_left', { username: socket.username });
            
            // Supprimer le socket des messages priv√©s
            userSockets.delete(socket.username);
            console.log(`üîí Utilisateur ${socket.username} supprim√© des messages priv√©s`);
            console.log(`üîí Utilisateurs restants:`, Array.from(userSockets.keys()));
            
            // Diffuser la nouvelle liste des utilisateurs de la room
            broadcastUsersList(socket.room);
        } else {
            console.log('Un client s\'est d√©connect√©, id:', socket.id);
        }
    });
});

httpServer.listen(PORT, () => {
    console.log('Le serveur est en √©coute sur le port 3000');
});

// Gestion des erreurs du serveur
httpServer.on('error', (error) => {
    if (error.code === 'EADDRINUSE') {
        console.error(`‚ùå Erreur: Le port ${PORT} est d√©j√† utilis√©.`);
        console.error('üí° Solution: Arr√™tez le processus existant ou changez le port.');
        process.exit(1);
    } else {
        console.error('‚ùå Erreur du serveur:', error);
        process.exit(1);
    }
});

// Gestion de l'arr√™t propre du serveur
process.on('SIGINT', () => {
    console.log('\nüõë Arr√™t du serveur...');
    httpServer.close(() => {
        console.log('‚úÖ Serveur arr√™t√© proprement');
        process.exit(0);
    });
});